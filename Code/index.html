<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <script src='d3.v4.min.js'></script>
    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700,900" rel="stylesheet">
    <script src="https://use.fontawesome.com/b0f0c8766a.js"></script>
    <link rel="icon" href="favicon-smile-o.ico">
</head>

<body>
    <div id="content-wrapper">
        <div id="content">
            <!-- svg plot here -->
            <div id="plot-container" class="content-card">
                <div id="tool-bar">
                    <span class="tool-bar-item">Trend Line
                        <input id='trend-line-checkbox' type='checkbox'>
                        <span id='pcc-text'></span>
                    </span>
                    <span class="tool-bar-item">Chart Lines
                        <input id='chart-lines-checkbox' type='checkbox'>
                    </span>
                    <span class="tool-bar-item"> Quartile
                        <input id='quartile-checkbox' type='checkbox'>
                        <select id='quartile-mode'>
                            <option id="quartile-mode-0" value="0">Minimal</option>
                            <option id="quartile-mode-1" value="1">Box and whisker X</option>
                            <option id="quartile-mode-2" value="2">Box and whisker Y</option>
                            <option id="quartile-mode-3" value="3">Box and whisker X &amp Y</option>
                        </select>
                    </span>
                </div>
            </div>
            <div id="message-container" class=" content-card">
                <div id="message-body">
                    <p id="message-text">
                        <span id="message-header">
                            Box-and-whisker plot quiz
                        </span>
                        <br>
                        <br> Move the
                        <span style="font-weight: 700;color:#4682b4">blue</span> point so that it's y value is in the first quartile of the box-and-whisker plot.
                        <br>
                        <br>Notice that changes to the x value of the point do not change the box-and-whisker plot. You might
                        remember that this is because this box-and-whisker plot represents the distribution of y values.
                        <br>
                        <br>When you think you have found a valid position, check your answer to unlock the next question.
                    </p>
                </div>
                <div id="navigation-bar">
                    <button id="check-answer-button" class="button button-check grey">
                        Check Answer
                    </button>
                    <button id="next-button" class="button green inactive">
                        <i class="fa fa-arrow-right" aria-hidden="true"></i>
                    </button>
                </div>

            </div>

        </div>

        <div id="footer">
            <span class="footer-element">
                <a href="mailto:jackbreidy@gmail.com">JACK REIDY</a>
            </span>
            <span class="footer-element">
                <a href="https://github.com/jackbereidy/CS448B_Final_Project">GITHUB</a>
            </span>
            <span class="footer-element">
                <a href="https://magrawala.github.io/cs448b-fa17/">CS 448B</a>
            </span>
        </div>
    </div>
</body>

</html>

<style>
    body {
        font-family: 'Roboto', sans-serif;
        background-color: #f1f1f1;
    }

    .tool-bar-item {
        margin-right: 25px;
    }

    .content-card {
        overflow: hidden;
        display: inline-block;
        background-color: #fff;
        /* -webkit-box-shadow: 0px 3px 5px -4px rgba(0, 0, 0, 0.75);
        -moz-box-shadow: 0px 3px 5px -4px rgba(0, 0, 0, 0.75);
        box-shadow: 0px 3px 5px -4px rgba(0, 0, 0, 0.75); */
    }

    #content-wrapper {
        text-align: center;
    }

    #content {
        margin-top: 40px;
    }

    #plot-container {
        border-radius: 5px 0px 0px 5px;
        margin-right: -4px;
        max-height: 700px;
    }

    #message-container {
        border-radius: 0px 5px 5px 0px;
        width: 400px;
        height: 700px;
        position: relative;
    }

    #message-body {
        margin-top: 50px;
        margin-left: 15px;
        text-align: left;
    }

    #message-header {
        font-weight: 500;
        font-size: 1.5em;
    }

    #message-text {
        overflow-y: auto;
        padding-right: 35px;
        max-height: 535px;
    }

    @media screen and (max-width: 1150px) {
        #plot-container {
            border-radius: 5px;
            margin-right: 0;
        }
        #message-container {
            margin-top: 20px;
            width: 700px;
            height: 400px;
            border-radius: 5px;
        }
        #message-body {
            margin-left: 0;
        }
        #message-text {
            padding-left: 35px;
            max-height: 230px;
        }
    }

    #navigation-bar {
        position: absolute;
        bottom: 0;
        margin-bottom: 50px;
        width: 100%;
    }

    #tool-bar {
        position: absolute;
        margin-left: 45px;
        margin-top: 50px;
    }

    #footer {
        margin-top: 35px;
        margin-bottom: 35px;
        font-weight: 500;
        font-size: 0.9em;
        text-decoration: none;
        color: #494949;
    }

    #footer a:link {
        text-decoration: none;
        color: inherit;
    }

    #footer a:visited {
        text-decoration: none;
        color: inherit;
    }

    #footer .footer-element {
        margin: 15px;
    }

    .button {
        background-color: #494949;
        display: inline-block;
        text-align: center;
        color: #fff;
        padding: 20px;
        padding-top: 10px;
        padding-bottom: 10px;
        text-decoration: none;
        font-size: 1.0em;
        margin: 5px;
        margin-bottom: 0px;
        margin-top: 0px;
        border: none;
        pointer-events: visible;
        cursor: pointer;
        font-family: 'Roboto', sans-serif;
        border-radius: 5px;
        font-weight: 300;
        outline: none;
    }

    .button:hover {
        filter: brightness(85%);
    }

    .button-check {
        width: 70%;
    }


    .button-next-hover {
        filter: brightness(85%);
    }

    .grey {
        background-color: #494949;
    }

    .green {
        background-color: #43C477;
    }

    .inactive {
        pointer-events: none;
        background-color: #ACACAC;
        color: #fff;
    }

    path {
        fill: none;
        stroke: #000;
    }

    .point {
        fill: #4682b4;
        stroke: #12548A;
        stroke-width: 2.0;
    }

    .uneditable-point {
        fill: #787878;
        stroke: #494949;
    }

    .editable-point {
        fill: #4682b4;
        stroke: #12548A;
        cursor: pointer;
    }

    .correct-point {
        fill: #58b446;
        stroke: rgb(18, 138, 24);
        cursor: pointer;
    }

    .chart-line {
        stroke: #aac6dc;
        stroke-width: 1.5;
        pointer-events: none;
    }

    .trend-line {
        stroke-dasharray: 5 5;
        stroke: #777;
        stroke-width: 1.5;
        pointer-events: none;
    }

    .text-rect {
        fill: #ffffffe1;
        -webkit-filter: drop-shadow(0px 2px 1.1px rgba(0, 0, 0, 0.25));
        filter: drop-shadow(0px 2px 1.1px rgba(0, 0, 0, 0.25));
        pointer-events: none;
    }

    .point-value-text {
        fill: #000;
        font-family: sans-serif;
        pointer-events: none;
    }

    .quartile-minimal {
        fill: none;
        stroke: #000;
        stroke-width: 1.5;
        pointer-events: none;
    }

    .quartile-line {
        stroke-width: 1.5;
        stroke: #000;
    }

    .quartile-line-median {
        stroke: #000;
    }

    .axis {
        stroke-width: 1.5;
        font-size: 0.7em;
        pointer-events: none;
    }

    .point-text {
        font-size: 10px;
        font-family: sans-serif;
        pointer-events: none;
        pointer-events: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }

    .quartile-box {
        fill: #eee;
        stroke-width: 1.5;
        stroke: #000;
        pointer-events: none;
    }

    .delete-rect {
        fill: #FF5858;
        cursor: pointer;
    }

    .delete-rect:hover {
        fill: #BF1313;
    }

    .delete-text {
        fill: #fff;
        font-weight: 500;
        font-size: 0.8em;
        pointer-events: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }
</style>

<script>


    console.log(window.location.href);
    let url = new URL(window.location.href);
    let quizID = url.searchParams.get('quizid');
    if (quizID) {
        console.log(quizID);
    } else {
        console.log('no quiz id');
    }
    let pageIndex = url.searchParams.get('pageindex');
    if (pageIndex) {
        console.log(pageIndex);
    } else {
        console.log('no page id');
    }

    let plotWidth = 500;
    let plotHeight = 500;
    let plotMargin = 100;
    let outerWidth = plotWidth + 2 * plotMargin;
    let outerHeight = plotHeight + 2 * plotMargin;

    let chartMinX = 0;
    let chartMaxX = 10;
    let chartMinY = 0;
    let chartMaxY = 10;

    let wholePlot = d3.select('#plot-container').append('svg')
        .attr('width', outerWidth)
        .attr('height', outerHeight)
        .attr('id', 'whole-chart');

    let plot = wholePlot.append('g')
        .attr('id', 'plot')
        .attr('transform', `translate(${plotMargin},${plotMargin})`);

    let points = plot.append('g')
        .attr('id', 'points');

    let xScale = d3.scaleLinear()
        .domain([chartMinX, chartMaxX])
        .range([0, plotWidth]);
    let yScale = d3.scaleLinear()
        .domain([chartMinY, chartMaxY])
        .range([plotHeight, 0]);

    let xAxis = plot.append('g')
        .attr('transform', `translate(0,${plotHeight})`)
        .attr('id', 'x-axis')
        .attr('class', 'axis')
        .call(d3.axisBottom(xScale));
    let yAxis = plot.append('g')
        .attr('id', 'y-axis')
        .attr('class', 'axis')
        .call(d3.axisLeft(yScale));

    let xQuartiles = plot.append('g')
        .attr('id', 'x-quartiles');
    let yQuartiles = plot.append('g')
        .attr('id', 'y-quartiles');

    let boxAndWhiskerElementsX = xQuartiles.append('g')
        .attr('transform', `translate(0, 40)`)
        .attr('class', 'boxAndWhiskerElements');
    let boxAndWhiskerElementsY = yQuartiles.append('g')
        .attr('transform', `translate(-40,0)`)
        .attr('class', 'boxAndWhiskerElements');

    let lowExtremeX = createQuartilePlotElement(boxAndWhiskerElementsX, true, true, false, false, "");
    let highExtremeX = createQuartilePlotElement(boxAndWhiskerElementsX, true, true, false, false, "");
    let lowerQuartileX = createQuartilePlotElement(boxAndWhiskerElementsX, true, false, false, true, "x-box-1");
    let upperQuartileX = createQuartilePlotElement(boxAndWhiskerElementsX, true, false, false, false, "");
    let medianX = createQuartilePlotElement(boxAndWhiskerElementsX, true, false, true, true, "x-box-2");

    let lowExtremeY = createQuartilePlotElement(boxAndWhiskerElementsY, false, true, false, false, "");
    let highExtremeY = createQuartilePlotElement(boxAndWhiskerElementsY, false, true, false, false, "");
    let lowerQuartileY = createQuartilePlotElement(boxAndWhiskerElementsY, false, false, false, false, "");
    let upperQuartileY = createQuartilePlotElement(boxAndWhiskerElementsY, false, false, false, true, "y-box-2");
    let medianY = createQuartilePlotElement(boxAndWhiskerElementsY, false, false, true, true, "y-box-1");

    let minimalElementsX = xQuartiles.append('g')
        .attr('class', 'minimalElements');
    minimalElementsX.append('line')
        .attr("class", "quartile-minimal line-0");
    minimalElementsX.append('line')
        .attr("class", "quartile-minimal line-1");
    minimalElementsX.append('line')
        .attr("class", "quartile-minimal line-2");
    minimalElementsX.append('line')
        .attr("class", "quartile-minimal line-3");

    let minimalElementsY = yQuartiles.append('g')
        .attr('class', 'minimalElements');
    minimalElementsY.append('line')
        .attr("class", "quartile-minimal line-0");
    minimalElementsY.append('line')
        .attr("class", "quartile-minimal line-1");
    minimalElementsY.append('line')
        .attr("class", "quartile-minimal line-2");
    minimalElementsY.append('line')
        .attr("class", "quartile-minimal line-3");

    let boxAndWhiskerLineX = lowExtremeX.append('line')
        .attr('id', 'box-and-whisker-line-x')
        .attr('class', 'quartile-line')
        .attr('y1', '0')
        .attr('y2', '0');

    let boxAndWhiskerLineY = lowExtremeY.append('line')
        .attr('id', 'box-and-whisker-line-y')
        .attr('class', 'quartile-line')
        .attr('x1', '0')
        .attr('x2', '0');

    let xBox1 = d3.select('#x-box-1');
    let xBox2 = d3.select('#x-box-2');
    let yBox1 = d3.select('#y-box-1');
    let yBox2 = d3.select('#y-box-2');

    let currentQuartileMode = 0;

    let pointData;

    let trendLineActive;
    let chartLinesActive;
    let quartileActive;

    function createMinimalQuartilePlotElement(group, isOuter) {
        let minimalGroup = quartile.append('g')
            .attr('class', 'minimalElement');
        let minimalLine = minimalGroup.append('line')
            .attr('class', 'minimal-line')
            .attr('x1', 0)
            .attr('x2', 1)
            .attr('y1', 0)
            .attr('y2', 0)
            .attr('stroke', '#100');
    }

    function createQuartilePlotElement(group, isHorizontal, isExtreme, isMedian, hasBox, boxAndWhiskerString) {
        let boxAndWhisker = group.append('g')
            .attr('transform', `translate(0,${plotHeight})`)
            .attr('class', 'boxAndWhiskerElement');
        let line = boxAndWhisker.append('line')
            .attr('class', 'quartile-line')
            .attr('x1', -6.25)
            .attr('x2', 6.25)
            .attr('y1', 0)
            .attr('y2', 0);
        if (hasBox) {
            let box = boxAndWhisker.append('rect')
                .attr('x', 0)
                .attr('y', -12.5)
                .attr('width', 10)
                .attr('height', 25)
                .attr('class', 'quartile-box')
                .attr('id', boxAndWhiskerString);
            if (!isHorizontal) box.attr('transform', `rotate(90)`);
        }
        if (isHorizontal) line.attr('transform', `rotate(90)`);
        if (isMedian) line.attr('class', 'quartile-line-median');

        if (!isExtreme) {
            line.attr('x1', -12.5)
                .attr('x2', 12.5);
        }
        return boxAndWhisker;
    }

    d3.csv('8_points.csv', parseInputRow, loadData);

    function parseInputRow(d) {
        return {
            id: +d.id,
            isEditable: +d.isEditable == 1,
            x: +d.x,
            y: +d.y,
            isSolution: +d.isSolution == 1,
        };
    }

    function loadData(error, data) {
        if (error) throw error;
        pointData = data;
        setUpState();
        drawUpdatedScatterPlot(data);
        drawSecondaryPlotElements();

    }

    function drawUpdatedScatterPlot(data) {

        pointData = data;


        let circles = points.selectAll('g.point-group');

        let updatedCircles = circles.data(pointData, d => d.id);

        let enterSelection = updatedCircles.enter();
        let newCircles = enterSelection.append('g')
            .attr('id', function (d) { return 'point-group-' + d.id; })
            .attr('class', function (d) { return 'point-group ' + ((d.isEditable) ? 'editable-point-group' : 'uneditable-point-group') });
        newCircles.append('circle')
            .attr('class', function (d) { return 'point ' + ((d.isEditable) ? 'editable-point' : 'uneditable-point') })
            .attr('r', 5)
            .attr('cx', function (d) { return xScale(d.x); })
            .attr('cy', function (d) { return yScale(d.y); })
            .call(d3.drag()
                .subject(function () {
                    var t = d3.select(this);
                    return { x: t.attr('cx'), y: t.attr('cy') };
                })
                .on('start', onPointDrag)
                .on('drag', onPointDrag)
                .on('end', function (d) {
                    displayDeleteButton(d);
                    updatePointInfoVisibility(d, false);
                }))
            .on('mouseover', function (d) {
                plot.select('#point-group-' + d.id).moveToFront();
                updatePointInfoVisibility(d, true);
            })
            .on('mouseout', function (d) {
                updatePointInfoVisibility(d, false);
            })
            .on('click', function (d) {

            });

        let text = newCircles.append('text')
            .attr('class', 'point-value-text')
            .attr('x', function (d) { return xScale(d.x); })
            .attr('y', function (d) { return yScale(d.y) - 15; })
            .text(function (d) { return getPointValueText(d) });

        let textRect = newCircles.append('rect')
            .attr('class', 'text-rect')
            .attr('x', function (d) { return xScale(d.x) - 17.5; })
            .attr('y', function (d) { return yScale(d.y) - 40; })
            .attr('width', 35)
            .attr('height', 25)
            .moveToBack();

        let deleteText = newCircles.append('text')
            .attr('class', 'delete-text')
            .attr('visibility', 'visible')
            .attr('x', function (d) { return xScale(d.x) - 3.4; })
            .attr('y', function (d) { return yScale(d.y) - 13.6; })
            .text('x')
            .moveToBack();

        let deleteRect = newCircles.append('rect')
            .attr('width', 15)
            .attr('height', 15)
            .attr('rx', 2)
            .attr('visibility', 'visible')
            .attr('x', function (d) { return xScale(d.x) - 7.5; })
            .attr('y', function (d) { return yScale(d.y) - 25; })
            .attr('class', 'delete-rect')
            .on('click', function (d, i) {
                deleteDataElement(d, i);
            })
            .moveToBack();


        text.attr('visibility', 'hidden');
        textRect.attr('visibility', 'hidden');
        deleteText.attr('visibility', 'hidden');
        deleteRect.attr('visibility', 'hidden');

        let unselectedCircles = updatedCircles.exit();

        updatedCircles.exit().remove();

        xAxis.moveToBack();
        yAxis.moveToBack();
    }
    function deleteDataElement(d, i) {
        console.log("delete");
        let filteredData = pointData;
        filteredData = filteredData.filter(function (dataPoint) {
            return dataPoint.id != d.id;
        });
        drawUpdatedScatterPlot(filteredData);
        drawSecondaryPlotElements();
    }

    function drawSecondaryPlotElements() {
        if (pointData.length > 2) {
            let sortedDataX = pointData.slice(0).sort(function (a, b) {
                return d3.ascending(a.x, b.x);
            });
            let sortedDataY = pointData.slice(0).sort(function (a, b) {
                return d3.ascending(a.y, b.y);
            });
            drawUpdatedQuartiles(pointData, sortedDataX, sortedDataY);
            drawUpdatedTrendLine(pointData, sortedDataX, sortedDataY);
            drawUpdatedChartLines(pointData, sortedDataX, sortedDataY);
        } else {
            plot.select("#trend-line").remove();
        }
    }
    function updatePointInfoVisibility(d, isVisible) {
        let pointGroup = plot.select('#point-group-' + d.id);
        let text = pointGroup.select('.point-value-text')
            .text(getPointValueText(d));

        let dim = text.node().getBBox();
        text.attr('x', function (d) { return xScale(d.x) - (dim.width) / 2; })
            .attr('y', function (d) { return yScale(d.y) - (dim.height + 20 + 10 - 5) / 2; });
        let textRect = pointGroup.select('.text-rect')
            .attr('width', dim.width + 20)
            .attr('height', dim.height + 20)
            .attr('x', function (d) { return xScale(d.x) - (dim.width + 20) / 2; })
            .attr('y', function (d) { return yScale(d.y) - (dim.height + 20 + 10); })

        let deleteText = pointGroup.select('.delete-text')
            .attr('x', function (d) { return xScale(d.x) - 3.4; })
            .attr('y', function (d) { return yScale(d.y) - 13.6; });

        let deleteRect = pointGroup.select('.delete-rect')
            .attr('x', function (d) { return xScale(d.x) - 7.5; })
            .attr('y', function (d) { return yScale(d.y) - 25; });

        if (isVisible) {
            pointGroup.select('.point-value-text').attr('visibility', 'visible');
            pointGroup.select('.text-rect').attr('visibility', 'visible');
        } else {
            pointGroup.select('.point-value-text').attr('visibility', 'hidden');
            pointGroup.select('.text-rect').attr('visibility', 'hidden');
        }

    }
    function onPointDrag(d) {
        let pointGroup = plot.select('#point-group-' + d.id);
        if (pointGroup.classed("editable-point-group")) {
            pointGroup.moveToFront();
            let dragPoint = pointGroup.select('.point');
            dragPoint.attr('cy',
                function (d) {
                    if (yScale.invert(d3.event.y) < chartMinY) {
                        d.y = chartMinY;
                        return yScale(chartMinY);
                    } else if (yScale.invert(d3.event.y) > chartMaxY) {
                        d.y = chartMaxY;
                        return yScale(chartMaxY);
                    } else {
                        d.y = yScale.invert(d3.event.y);
                        return d3.event.y;
                    }
                })
                .attr('cx', function (d) {
                    if (xScale.invert(d3.event.x) < chartMinX) {
                        d.x = chartMinX;
                        return xScale(chartMinX);
                    } else if (xScale.invert(d3.event.x) > chartMaxX) {
                        d.x = chartMaxX;
                        return xScale(chartMaxX);
                    } else {
                        d.x = xScale.invert(d3.event.x);
                        return d3.event.x;
                    }
                })
            updatePointInfoVisibility(d, true);
            drawSecondaryPlotElements(pointData);
        }

    }

    let timeout;
    let lastPointIndex;
    function displayDeleteButton(d) {
        if (lastPointIndex == d.id) clearTimeout(timeout);
        lastPointIndex = +d.id;
        let pointGroup = plot.select('#point-group-' + d.id);
        pointGroup.select('.delete-text').attr('visibility', 'visible');
        pointGroup.select('.delete-rect').attr('visibility', 'visible');
        timeout = setTimeout(function (d) {
            pointGroup.select('.delete-text').attr('visibility', 'hidden');
            pointGroup.select('.delete-rect').attr('visibility', 'hidden');
        }, 2000);
    }

    function getPointValueText(d) {
        let string = d.x.toFixed(2) + ", " + d.y.toFixed(2);
        return string;
    }
    var line = d3.line()
        .x(function (d) { return xScale(d.x) })
        .y(function (d) { return yScale(d.y) });
    function drawUpdatedTrendLine(data, sortedDataX, sortedDataY) {
        plot.select("#trend-line").remove();
        if (trendLineActive) {
            let sumX = 0;
            let sumY = 0;
            let sumXY = 0;
            let sumXSquare = 0;
            let sumYSquare = 0;
            let n = data.length;

            for (i = 0; i < sortedDataX.length; i++) {
                sumX += sortedDataX[i].x;
                sumY += sortedDataX[i].y;
                sumXY += sortedDataX[i].x * sortedDataX[i].y;
                sumXSquare += sortedDataX[i].x * sortedDataX[i].x;
                sumYSquare += sortedDataX[i].y * sortedDataX[i].y;
            }

            let a = ((sumY * sumXSquare) - (sumX * sumXY)) / ((n * sumXSquare) - (sumX * sumX));
            let b = ((n * sumXY) - (sumX * sumY)) / ((n * sumXSquare) - (sumX * sumX));
            //console.log("a: " + a + ", b: " + b);

            let trendLine = plot.append("line")
                .attr('x1', xScale(sortedDataX[0].x))
                .attr('y1', yScale(sortedDataX[0].x * b + a))
                .attr('x2', xScale(sortedDataX[sortedDataX.length - 1].x))
                .attr('y2', yScale(sortedDataX[sortedDataX.length - 1].x * b + a))
                .attr('id', 'trend-line')
                .attr('class', 'trend-line');

            trendLine.moveToBack();

            let pccNumerator = (n * sumXY) - (sumX * sumY);
            let pccDenominator = Math.sqrt(((n * sumXSquare) - (sumX * sumX)) * ((n * sumYSquare) - (sumY * sumY)));
            let pcc = pccNumerator / pccDenominator;

            // document.getElementById("pcc-text").textContent = 'Pearson correlation coefficient (r): ' + pcc.toFixed(3);
        } else {
            document.getElementById("pcc-text").textContent = '';
        }
    }

    function drawUpdatedChartLines(data, sortedDataX, sortedDataY) {

        plot.select("g#chart-lines").remove();

        if (chartLinesActive) {
            let lines = plot.append('g')
                .attr('id', 'chart-lines');

            lines.append("path")
                .datum(sortedDataX)
                .attr("class", "chart-line")
                .attr("d", line);

            lines.moveToBack();
        }

    }

    function updateQuartileVisibility() {
        if (quartileActive) {
            xQuartiles.attr('visibility', 'visible');
            yQuartiles.attr('visibility', 'visible');
            switch (currentQuartileMode) {
                case 3:
                    xAxis.attr('visibility', 'visible');
                    yAxis.attr('visibility', 'visible');
                    yQuartiles.select('.boxAndWhiskerElements').attr('visibility', 'visible');
                    xQuartiles.select('.boxAndWhiskerElements').attr('visibility', 'visible');
                    yQuartiles.select('.minimalElements').attr('visibility', 'hidden');
                    xQuartiles.select('.minimalElements').attr('visibility', 'hidden');
                    break;
                case 2:
                    xAxis.attr('visibility', 'visible');
                    yAxis.attr('visibility', 'visible');
                    yQuartiles.select('.boxAndWhiskerElements').attr('visibility', 'visible');
                    xQuartiles.select('.boxAndWhiskerElements').attr('visibility', 'hidden');
                    yQuartiles.select('.minimalElements').attr('visibility', 'hidden');
                    xQuartiles.select('.minimalElements').attr('visibility', 'hidden');
                    break;
                case 1:
                    xAxis.attr('visibility', 'visible');
                    yAxis.attr('visibility', 'visible');
                    yQuartiles.select('.boxAndWhiskerElements').attr('visibility', 'hidden');
                    xQuartiles.select('.boxAndWhiskerElements').attr('visibility', 'visible');
                    yQuartiles.select('.minimalElements').attr('visibility', 'hidden');
                    xQuartiles.select('.minimalElements').attr('visibility', 'hidden');
                    break;
                case 0:
                default:
                    xAxis.attr('visibility', 'hidden');
                    yAxis.attr('visibility', 'hidden');
                    yQuartiles.select('.boxAndWhiskerElements').attr('visibility', 'hidden');
                    xQuartiles.select('.boxAndWhiskerElements').attr('visibility', 'hidden');
                    yQuartiles.select('.minimalElements').attr('visibility', 'visible');
                    xQuartiles.select('.minimalElements').attr('visibility', 'visible');
            }
        } else {
            xAxis.attr('visibility', 'visible');
            yAxis.attr('visibility', 'visible');
            xQuartiles.attr('visibility', 'hidden');
            yQuartiles.attr('visibility', 'hidden');
            yQuartiles.select('.minimalElements').attr('visibility', 'hidden');
            xQuartiles.select('.minimalElements').attr('visibility', 'hidden');
            yQuartiles.select('.boxAndWhiskerElements').attr('visibility', 'hidden');
            xQuartiles.select('.boxAndWhiskerElements').attr('visibility', 'hidden');
        }

    }
    let lowerQuartileYValue = 0;
    let upperQuartileYValue = 0;
    let medianYValue = 0;
    let lowExtremeYValue = 0;
    let highExtremeYValue = 0;

    let lowerQuartileXValue = 0;
    let upperQuartileXValue = 0;
    let medianXValue = 0;
    let lowExtremeXValue = 0;
    let highExtremeXValue = 0;
    function drawUpdatedQuartiles(data, sortedDataX, sortedDataY) {
        if (quartileActive) {
            medianXValue = xScale(getMedianValue(sortedDataX, true));
            lowExtremeXValue = xScale(sortedDataX[0].x);
            highExtremeXValue = xScale(sortedDataX[sortedDataX.length - 1].x);

            medianX.attr('transform', `translate(${medianXValue},${plotHeight})`);
            lowExtremeX.attr('transform', `translate(${lowExtremeXValue},${plotHeight})`);
            highExtremeX.attr('transform', `translate(${highExtremeXValue},${plotHeight})`);

            lowerQuartileXValue = 0;
            upperQuartileXValue = 0;
            if (data.length % 2 == 0) {
                lowerQuartileXValue = xScale(getMedianValue(sortedDataX.slice(0, sortedDataX.length / 2 - 1), true));
                upperQuartileXValue = xScale(getMedianValue(sortedDataX.slice(sortedDataX.length / 2 + 1, sortedDataX.length), true));
                lowerQuartileX.attr('transform', `translate(${lowerQuartileXValue},${plotHeight})`);
                upperQuartileX.attr('transform', `translate(${upperQuartileXValue},${plotHeight})`);
            } else {
                lowerQuartileXValue = xScale(getMedianValue(sortedDataX.slice(0, sortedDataX.length / 2), true));
                upperQuartileXValue = xScale(getMedianValue(sortedDataX.slice(sortedDataX.length / 2 + 1, sortedDataX.length), true));
                lowerQuartileX.attr('transform', `translate(${lowerQuartileXValue},${plotHeight})`);
                upperQuartileX.attr('transform', `translate(${upperQuartileXValue},${plotHeight})`);
            }

            minimalElementsX.select('line.line-0')
                .attr('x1', lowExtremeXValue)
                .attr('y1', yScale(0))
                .attr('x2', lowerQuartileXValue)
                .attr('y2', yScale(0));
            minimalElementsX.select('line.line-1')
                .attr('x1', lowerQuartileXValue)
                .attr('y1', yScale(0) - 3)
                .attr('x2', medianXValue - 3)
                .attr('y2', yScale(0) - 3);
            minimalElementsX.select('line.line-2')
                .attr('x1', medianXValue + 3)
                .attr('y1', yScale(0) - 3)
                .attr('x2', upperQuartileXValue)
                .attr('y2', yScale(0) - 3);
            minimalElementsX.select('line.line-3')
                .attr('x1', upperQuartileXValue)
                .attr('y1', yScale(0))
                .attr('x2', highExtremeXValue)
                .attr('y2', yScale(0));

            xBox1.attr('width', medianXValue - lowerQuartileXValue);
            xBox2.attr('width', upperQuartileXValue - medianXValue);

            boxAndWhiskerLineX.attr('x1', 0)
                .attr('x2', highExtremeXValue - lowExtremeXValue);

            medianYValue = yScale(getMedianValue(sortedDataY, false));
            lowExtremeYValue = yScale(sortedDataY[0].y);
            highExtremeYValue = yScale(sortedDataY[sortedDataY.length - 1].y);

            medianY.attr('transform', `translate(0,${medianYValue})`);
            lowExtremeY.attr('transform', `translate(0,${lowExtremeYValue})`);
            highExtremeY.attr('transform', `translate(0,${highExtremeYValue})`);

            lowerQuartileYValue = 0;
            upperQuartileYValue = 0;
            if (data.length % 2 == 0) {
                lowerQuartileYValue = yScale(getMedianValue(sortedDataY.slice(0, sortedDataY.length / 2 - 1), false));
                upperQuartileYValue = yScale(getMedianValue(sortedDataY.slice(sortedDataY.length / 2 + 1, sortedDataY.length), false));
                lowerQuartileY.attr('transform', `translate(0,${lowerQuartileYValue})`);
                upperQuartileY.attr('transform', `translate(0,${upperQuartileYValue})`);
            } else {
                lowerQuartileYValue = yScale(getMedianValue(sortedDataY.slice(0, sortedDataY.length / 2), false));
                upperQuartileYValue = yScale(getMedianValue(sortedDataY.slice(sortedDataY.length / 2 + 1, sortedDataY.length), false));
                lowerQuartileY.attr('transform', `translate(0,${lowerQuartileYValue})`);
                upperQuartileY.attr('transform', `translate(0,${upperQuartileYValue})`);
            }

            minimalElementsY.select('line.line-0')
                .attr('y1', lowExtremeYValue)
                .attr('x1', xScale(0) + 1)
                .attr('y2', lowerQuartileYValue)
                .attr('x2', xScale(0) + 1);
            minimalElementsY.select('line.line-1')
                .attr('y1', lowerQuartileYValue)
                .attr('x1', xScale(0) + 3)
                .attr('y2', medianYValue + 3)
                .attr('x2', xScale(0) + 3);
            minimalElementsY.select('line.line-2')
                .attr('y1', medianYValue - 3)
                .attr('x1', xScale(0) + 3)
                .attr('y2', upperQuartileYValue)
                .attr('x2', xScale(0) + 3);
            minimalElementsY.select('line.line-3')
                .attr('y1', upperQuartileYValue)
                .attr('x1', xScale(0) + 1)
                .attr('y2', highExtremeYValue)
                .attr('x2', xScale(0) + 1);

            yBox1.attr('width', lowerQuartileYValue - medianYValue);
            yBox2.attr('width', medianYValue - upperQuartileYValue);

            boxAndWhiskerLineY.attr('y1', 0)
                .attr('y2', highExtremeYValue - lowExtremeYValue);

            xQuartiles.moveToBack();
            yQuartiles.moveToBack();
        }
    }

    function getMedianValue(data, isHorizontal) {
        if (data.length % 2 == 0) {
            let lower, higher = 0;
            if (isHorizontal) {
                lower = data[Math.floor(data.length / 2) - 1].x;
                higher = data[Math.floor(data.length / 2)].x;
            } else {
                lower = data[Math.floor(data.length / 2) - 1].y;
                higher = data[Math.floor(data.length / 2)].y;
            }
            return (lower + higher) / 2;
        } else {
            if (isHorizontal) {
                return data[Math.floor(data.length / 2)].x;
            } else {
                return data[Math.floor(data.length / 2)].y;
            }
        }
    }

    function setUpState() {
        trendLineActive = false;
        quartileActive = true;
        chartLinesActive = false;
        selectBox = document.getElementById('quartile-mode');
        currentQuartileMode = 2;
        selectBox.value = currentQuartileMode;
        setUpInput();
    }

    let answerButton;
    let nextButton;
    function setUpInput() {
        answerButton = d3.select('#check-answer-button')
            .on('click', function () {
                checkAnswer();
            })
        nextButton = d3.select('#next-button')
            .on('click', function () {
                location.reload();
            })
        d3.select('#trend-line-checkbox')
            .property('checked', trendLineActive)
            .on('change', function () {
                trendLineActive = this.checked;
                drawSecondaryPlotElements(pointData);
            });
        d3.select('#chart-lines-checkbox')
            .property('checked', chartLinesActive)
            .on('change', function () {
                chartLinesActive = this.checked;
                drawSecondaryPlotElements(pointData);
            });
        d3.select('#quartile-checkbox')
            .property('checked', quartileActive)
            .on('change', function () {
                quartileActive = this.checked;
                currentQuartileMode = parseInt(selectBox.options[selectBox.selectedIndex].value);
                updateQuartileVisibility();
                drawSecondaryPlotElements(pointData);
            });
        let quartileModeSelect = d3.select('#quartile-mode')
            .on('change', function () {
                currentQuartileMode = parseInt(this.options[this.selectedIndex].value);
                if (quartileActive) {
                    updateQuartileVisibility();
                }
            });

        updateQuartileVisibility();

    }

    function checkAnswer() {
        let circles = points.selectAll('g.point-group');
        let updatedCircles = circles.data(pointData, d => d.id);
        let enterSelection = updatedCircles.enter();
        circles.each(function (d) {
            if (d.isSolution) {
                console.log("solution point with id: " + d.id + " and y value: " + d.y);
                if (+d.y >= yScale.invert(lowerQuartileYValue) && +d.y <= yScale.invert(medianYValue)) {
                    console.log("yay correct answer!");
                    answerButton.text("Correct!")
                        .attr("class", "button button-check inactive");
                    nextButton.attr("class", "button green");
                    d3.select('#point-group-' + d.id).attr('class', 'point-group uneditable-point-group')
                        .select("circle").attr('class', 'point correct-point');

                } else {
                    answerButton.text("Check Answer Again");
                }

            }
        });

    }

    // moveToBack(), moveToFront() attribution: http://blockbuilder.org/eesur/4e0a69d57d3bfc8a82c2
    d3.selection.prototype.moveToBack = function () {
        return this.each(function () {
            var firstChild = this.parentNode.firstChild;
            if (firstChild) {
                this.parentNode.insertBefore(this, firstChild);
            }
        });
    };
    d3.selection.prototype.moveToFront = function () {
        return this.each(function () {
            this.parentNode.appendChild(this);
        });
    };

</script>