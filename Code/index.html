<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <script src='https://d3js.org/d3.v4.min.js'></script>
</head>

<body>
    <p id='pcc-text'></p>
    <input id='trend-line-checkbox' type='checkbox'>

</body>

</html>

<style>
    path {
        fill: none;
        stroke: #aaa;
    }
</style>

<script>
    let plotWidth = 500;
    let plotHeight = 500;
    let plotMargin = 100;
    let outerWidth = plotWidth + 2 * plotMargin;
    let outerHeight = plotHeight + 2 * plotMargin;

    let chartMinX = 0;
    let chartMaxX = 10;
    let chartMinY = 0;
    let chartMaxY = 10;

    let wholePlot = d3.select('body').append('svg')
        .attr('width', outerWidth)
        .attr('height', outerHeight)
        .attr('id', 'whole-chart');

    let plot = wholePlot.append('g')
        .attr('id', 'plot')
        .attr('transform', `translate(${plotMargin},${plotMargin})`);

    let points = plot.append('g')
        .attr('id', 'points');

    let xScale = d3.scaleLinear()
        .domain([chartMinX, chartMaxX])
        .range([0, plotWidth]);
    let yScale = d3.scaleLinear()
        .domain([chartMinY, chartMaxY])
        .range([plotHeight, 0]);

    let xAxis = plot.append('g')
        .attr('transform', `translate(0,${plotHeight})`)
        .call(d3.axisBottom(xScale));
    let yAxis = plot.append('g')
        .call(d3.axisLeft(yScale));

    let xQuartiles = plot.append('g')
        .attr('id', 'x-quartiles');
    let yQuartiles = plot.append('g')
        .attr('id', 'y-quartiles');

    let lowExtremeX = createQuartilePlotElement(xQuartiles, true, true);
    let highExtremeX = createQuartilePlotElement(xQuartiles, true, true);
    let lowerQuartileX = createQuartilePlotElement(xQuartiles, true, false);
    let upperQuartileX = createQuartilePlotElement(xQuartiles, true, false);
    let medianX = createQuartilePlotElement(xQuartiles, true, false);

    let lowExtremeY = createQuartilePlotElement(yQuartiles, false, true);
    let highExtremeY = createQuartilePlotElement(yQuartiles, false, true);
    let lowerQuartileY = createQuartilePlotElement(yQuartiles, false, false);
    let upperQuartileY = createQuartilePlotElement(yQuartiles, false, false);
    let medianY = createQuartilePlotElement(yQuartiles, false, false);

    let pointData;

    let trendLineActive = false;

    function createQuartilePlotElement(group, isHorizontal, isExtreme) {
        let quartile = group.append('g')
            .attr('transform', `translate(0,${plotHeight})`)
            .attr('class', 'quartileElement');
        quartile.append('circle')
            .attr('class', 'quartile-circle')
            .attr('r', '5.0');
        if (!isExtreme) {
            let line = quartile.append('line')
                .attr('class', 'quartile-line')
                .attr('x1', -30)
                .attr('x2', 30)
                .attr('y1', 0)
                .attr('y2', 0)
                .attr('stroke', '#000');
            if (isHorizontal) {
                line.attr('transform', `rotate(90)`);
            }
        }
        return quartile;
    }

    d3.csv('animals.csv', parseInputRow, loadData);

    function parseInputRow(d) {
        return {
            id: +d.id,
            animal: d.animal,
            x: +d.weight,
            y: +d.height,
            name: d.name
        };
    }

    function loadData(error, data) {
        if (error) throw error;
        pointData = data;

        drawSecondaryPlotElements(pointData);
    }

    function drawUpdatedScatterPlot(data) {

        let circles = points.selectAll('circle.point');

        let updatedCircles = circles.data(data, d => d.id);

        let enterSelection = updatedCircles.enter();
        let newCircles = enterSelection.append('circle')
            .attr('id', function (d) { return 'point-' + d.id; })
            .attr('class', 'point')
            .attr('r', 5)
            .attr('cx', function (d) { return xScale(d.x); })
            .attr('cy', function (d) { return yScale(d.y); })
            .style('fill', function (d) {
                return d.animal === 'cat' ? 'steelblue' : 'steelblue';
            })
            .call(d3.drag()
                .subject(function () {
                    var t = d3.select(this);
                    return { x: t.attr('cx'), y: t.attr('cy') };
                })
                .on('start', onPointDrag)
                .on('drag', onPointDrag));

        let unselectedCircles = updatedCircles.exit();

        updatedCircles.exit().remove();
    }

    function drawSecondaryPlotElements(pointData) {
        let sortedDataX = pointData.slice(0).sort(function (a, b) {
            return d3.ascending(a.x, b.x);
        });
        let sortedDataY = pointData.slice(0).sort(function (a, b) {
            return d3.ascending(a.y, b.y);
        });
        drawUpdatedScatterPlot(pointData, sortedDataX, sortedDataY);
        drawUpdatedQuartiles(pointData, sortedDataX, sortedDataY);
        if (trendLineActive) drawUpdatedTrendLine(pointData, sortedDataX, sortedDataY);
        drawUpdatedChartLines(pointData, sortedDataX, sortedDataY);
    }

    function onPointDrag(d) {
        plot.select('#point-' + d.id)
            .attr('cy', function (d) {
                if (yScale.invert(d3.event.y) < chartMinY) {
                    d.y = chartMinY;
                    return yScale(chartMinY);
                } else if (yScale.invert(d3.event.y) > chartMaxY) {
                    d.y = chartMaxY;
                    return yScale(chartMaxY);
                } else {
                    d.y = yScale.invert(d3.event.y);
                    return d3.event.y;
                }
            })
            .attr('cx', function (d) {
                if (xScale.invert(d3.event.x) < chartMinX) {
                    d.x = chartMinX;
                    return xScale(chartMinX);
                } else if (xScale.invert(d3.event.x) > chartMaxX) {
                    d.x = chartMaxX;
                    return xScale(chartMaxX);
                } else {
                    d.x = xScale.invert(d3.event.x);
                    return d3.event.x;
                }
            })
        drawSecondaryPlotElements(pointData);
    }
    var line = d3.line()
        .x(function (d) { return xScale(d.x) })
        .y(function (d) { return yScale(d.y) });
    function drawUpdatedTrendLine(data, sortedDataX, sortedDataY) {
        let sumX = 0;
        let sumY = 0;
        let sumXY = 0;
        let sumXSquare = 0;
        let sumYSquare = 0;
        let n = data.length;

        for (i = 0; i < sortedDataX.length; i++) {
            sumX += sortedDataX[i].x;
            sumY += sortedDataX[i].y;
            sumXY += sortedDataX[i].x * sortedDataX[i].y;
            sumXSquare += sortedDataX[i].x * sortedDataX[i].x;
            sumYSquare += sortedDataX[i].y * sortedDataX[i].y;
        }

        let a = ((sumY * sumXSquare) - (sumX * sumXY)) / ((n * sumXSquare) - (sumX * sumX));
        let b = ((n * sumXY) - (sumX * sumY)) / ((n * sumXSquare) - (sumX * sumX));
        console.log("a: " + a + ", b: " + b);

        plot.select("#trend-line").remove();

        let trendLine = plot.append("line")
            .attr('x1', xScale(sortedDataX[0].x))
            .attr('y1', yScale(sortedDataX[0].x * b + a))
            .attr('x2', xScale(sortedDataX[sortedDataX.length-1].x))
            .attr('y2', yScale(sortedDataX[sortedDataX.length-1].x * b + a))
            .attr("fill", "none")
            .attr('id', 'trend-line')
            .attr("class", "chart-line")
            .attr("stroke", "grey")
            .attr("stroke-linejoin", "round")
            .attr("stroke-linecap", "round")
            .attr("stroke-width", 1.5)
            .attr("pointer-events", "none");

        trendLine.moveToBack();

        let pccNumerator = (n * sumXY) - (sumX * sumY);
        let pccDenominator = Math.sqrt( ((n * sumXSquare) - (sumX * sumX)) * ((n * sumYSquare) - (sumY * sumY)) );
        let pcc = pccNumerator / pccDenominator;
        
        document.getElementById("pcc-text").textContent = 'Pearson correlation coefficient (r): ' + pcc.toFixed(3);

    }

    function drawUpdatedChartLines(data, sortedDataX, sortedDataY) {
        plot.select("g#chart-lines").remove();

        let lines = plot.append('g')
            .attr('id', 'chart-lines');

        lines.append("path")
            .datum(sortedDataX)
            .attr("class", "chart-line")
            .attr("stroke-linejoin", "round")
            .attr("stroke-linecap", "round")
            .attr("stroke-width", 1.5)
            .attr("d", line)
            .attr("pointer-events", "none");

        lines.moveToBack();

    }

    function drawUpdatedQuartiles(data, sortedDataX, sortedDataY) {

        let medianXValue = xScale(getMedianValue(sortedDataX, true));
        let lowExtremeXValue = xScale(sortedDataX[0].x);
        let highExtremeXValue = xScale(sortedDataX[sortedDataX.length - 1].x);

        medianX.attr('transform', `translate(${medianXValue},${plotHeight})`);
        lowExtremeX.attr('transform', `translate(${lowExtremeXValue},${plotHeight})`);
        highExtremeX.attr('transform', `translate(${highExtremeXValue},${plotHeight})`);

        let lowerQuartileXValue = 0;
        let upperQuartileXValue = 0;
        if (data.length % 2 == 0) {
            lowerQuartileXValue = xScale(getMedianValue(sortedDataX.slice(0, sortedDataX.length / 2 - 1), true));
            upperQuartileXValue = xScale(getMedianValue(sortedDataX.slice(sortedDataX.length / 2 + 1, sortedDataX.length), true));
            lowerQuartileX.attr('transform', `translate(${lowerQuartileXValue},${plotHeight})`);
            upperQuartileX.attr('transform', `translate(${upperQuartileXValue},${plotHeight})`);
        } else {
            lowerQuartileXValue = xScale(getMedianValue(sortedDataX.slice(0, sortedDataX.length / 2), true));
            upperQuartileXValue = xScale(getMedianValue(sortedDataX.slice(sortedDataX.length / 2 + 1, sortedDataX.length), true));
            lowerQuartileX.attr('transform', `translate(${lowerQuartileXValue},${plotHeight})`);
            upperQuartileX.attr('transform', `translate(${upperQuartileXValue},${plotHeight})`);
        }

        let medianYValue = yScale(getMedianValue(sortedDataY, false));
        let lowExtremeYValue = yScale(sortedDataY[0].y);
        let highExtremeYValue = yScale(sortedDataY[sortedDataY.length - 1].y);

        medianY.attr('transform', `translate(0,${medianYValue})`);
        lowExtremeY.attr('transform', `translate(0,${lowExtremeYValue})`);
        highExtremeY.attr('transform', `translate(0,${highExtremeYValue})`);

        let lowerQuartileYValue = 0;
        let upperQuartileYValue = 0;
        if (data.length % 2 == 0) {
            lowerQuartileYValue = yScale(getMedianValue(sortedDataY.slice(0, sortedDataY.length / 2 - 1), false));
            upperQuartileYValue = yScale(getMedianValue(sortedDataY.slice(sortedDataY.length / 2 + 1, sortedDataY.length), false));
            lowerQuartileY.attr('transform', `translate(0,${lowerQuartileYValue})`);
            upperQuartileY.attr('transform', `translate(0,${upperQuartileYValue})`);
        } else {
            lowerQuartileYValue = yScale(getMedianValue(sortedDataY.slice(0, sortedDataY.length / 2), false));
            upperQuartileYValue = yScale(getMedianValue(sortedDataY.slice(sortedDataY.length / 2 + 1, sortedDataY.length), false));
            lowerQuartileY.attr('transform', `translate(0,${lowerQuartileYValue})`);
            upperQuartileY.attr('transform', `translate(0,${upperQuartileYValue})`);
        }

        xQuartiles.moveToBack();
        yQuartiles.moveToBack();

    }

    function getMedianValue(data, isHorizontal) {
        if (data.length % 2 == 0) {
            let lower, higher = 0;
            if (isHorizontal) {
                lower = data[Math.floor(data.length / 2) - 1].x;
                higher = data[Math.floor(data.length / 2)].x;
            } else {
                lower = data[Math.floor(data.length / 2) - 1].y;
                higher = data[Math.floor(data.length / 2)].y;
            }
            return (lower + higher) / 2;
        } else {
            if (isHorizontal) {
                return data[Math.floor(data.length / 2)].x;
            } else {
                return data[Math.floor(data.length / 2)].y;
            }
        }
    }

    function setUpInputBar() {
        d3.select('#trend-line-checkbox')
            .on('change', function () {
                trendLineActive = this.checked;
                console.log('changed trend line active');
                if (trendLineActive) drawUpdatedTrendLine();
            });
    }

    // moveToBack(), moveToFront() attribution: http://blockbuilder.org/eesur/4e0a69d57d3bfc8a82c2
    d3.selection.prototype.moveToBack = function () {
        return this.each(function () {
            var firstChild = this.parentNode.firstChild;
            if (firstChild) {
                this.parentNode.insertBefore(this, firstChild);
            }
        });
    };
    d3.selection.prototype.moveToFront = function () {
        return this.each(function () {
            this.parentNode.appendChild(this);
        });
    };

</script>